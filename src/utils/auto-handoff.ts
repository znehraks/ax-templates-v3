/**
 * Auto-HANDOFF generation utilities
 * Automatically generates HANDOFF.md when context is low or tasks are completed
 */
import path from 'path';
import { ensureDirAsync, writeFile } from './fs.js';
import { getTimestamp, getReadableTimestamp } from './shell.js';
import { ProgressManager } from '../core/state/progress.js';
import { getStageName, STAGE_IDS } from '../types/stage.js';
import type { StageId } from '../types/stage.js';

/**
 * Handoff trigger types
 */
export type HandoffTrigger = 'context_low' | 'task_count' | 'stage_complete' | 'manual' | 'critical';

/**
 * Handoff generation options
 */
export interface HandoffOptions {
  trigger: HandoffTrigger;
  contextPercent?: number;
  taskCount?: number;
  completedTasks?: string[];
  pendingTasks?: string[];
  keyDecisions?: string[];
  modifiedFiles?: string[];
  activeIssues?: string[];
  notes?: string;
  compact?: boolean;
}

/**
 * Handoff result
 */
export interface HandoffResult {
  path: string;
  archivePath: string | null;
  content: string;
}

/**
 * Generate auto-HANDOFF.md
 */
export async function generateAutoHandoff(
  projectRoot: string,
  options: HandoffOptions
): Promise<HandoffResult | null> {
  try {
    // Load progress info
    const progressManager = new ProgressManager(projectRoot);
    const progress = await progressManager.load();

    if (!progress) {
      console.error('Could not load progress.json');
      return null;
    }

    const currentStage = progress.current_stage as StageId;
    const stageName = getStageName(currentStage);
    const timestamp = getReadableTimestamp();
    const isoTimestamp = getTimestamp();

    // Get completed stages
    const completedStages = STAGE_IDS.filter(
      stageId => progress.stages?.[stageId]?.status === 'completed'
    );

    // Get sprint info
    const sprintInfo = progress.current_iteration
      ? `${progress.current_iteration.current_sprint ?? 1}/${progress.current_iteration.total_sprints ?? 3}`
      : '1/1';

    // Generate content based on mode
    const content = options.compact
      ? generateCompactHandoff({
          currentStage,
          stageName,
          timestamp,
          trigger: options.trigger,
          contextPercent: options.contextPercent,
          sprintInfo,
          completedStages,
        })
      : generateFullHandoff({
          currentStage,
          stageName,
          timestamp,
          isoTimestamp,
          trigger: options.trigger,
          contextPercent: options.contextPercent,
          sprintInfo,
          completedStages,
          completedTasks: options.completedTasks,
          pendingTasks: options.pendingTasks,
          keyDecisions: options.keyDecisions,
          modifiedFiles: options.modifiedFiles,
          activeIssues: options.activeIssues,
          notes: options.notes,
        });

    // Write HANDOFF.md
    const handoffPath = path.join(projectRoot, 'HANDOFF.md');
    await writeFile(handoffPath, content);

    // Archive copy
    const handoffsDir = path.join(projectRoot, 'state', 'handoffs');
    await ensureDirAsync(handoffsDir);

    const archiveFilename = `handoff-${isoTimestamp.replace(/[:.]/g, '-').slice(0, 19)}-${currentStage}.md`;
    const archivePath = path.join(handoffsDir, archiveFilename);
    await writeFile(archivePath, content);

    return {
      path: handoffPath,
      archivePath,
      content,
    };
  } catch (error) {
    console.error('Failed to generate handoff:', error);
    return null;
  }
}

/**
 * Generate compact handoff (minimal essential info)
 */
function generateCompactHandoff(opts: {
  currentStage: string;
  stageName: string;
  timestamp: string;
  trigger: HandoffTrigger;
  contextPercent?: number;
  sprintInfo: string;
  completedStages: string[];
}): string {
  const triggerReason = getTriggerReason(opts.trigger, opts.contextPercent);

  return `# HANDOFF - Compact
> ${opts.timestamp}
> Trigger: ${triggerReason}

## Quick Resume
- **Stage**: ${opts.currentStage} (${opts.stageName})
- **Sprint**: ${opts.sprintInfo}
- **Completed**: ${opts.completedStages.join(', ') || 'none'}

## Instructions
1. Check \`state/progress.json\`
2. Review \`state/context/\` for snapshots
3. Continue from stage: **${opts.currentStage}**

---
*Auto-generated by claude-symphony*
`;
}

/**
 * Generate full handoff (detailed recovery info)
 */
function generateFullHandoff(opts: {
  currentStage: string;
  stageName: string;
  timestamp: string;
  isoTimestamp: string;
  trigger: HandoffTrigger;
  contextPercent?: number;
  sprintInfo: string;
  completedStages: string[];
  completedTasks?: string[];
  pendingTasks?: string[];
  keyDecisions?: string[];
  modifiedFiles?: string[];
  activeIssues?: string[];
  notes?: string;
}): string {
  const triggerReason = getTriggerReason(opts.trigger, opts.contextPercent);

  let content = `# HANDOFF - Session Transfer
> Generated: ${opts.isoTimestamp}
> Trigger: ${triggerReason}

## Session Summary

| Field | Value |
|-------|-------|
| Current Stage | ${opts.currentStage}: ${opts.stageName} |
| Sprint | ${opts.sprintInfo} |
| Completed Stages | ${opts.completedStages.join(', ') || 'none'} |

## Context State

This handoff was generated due to: **${triggerReason}**

`;

  if (opts.contextPercent !== undefined) {
    content += `### Context Usage
- Remaining: ${opts.contextPercent}%
- Status: ${opts.contextPercent <= 40 ? 'CRITICAL' : opts.contextPercent <= 50 ? 'ACTION REQUIRED' : 'WARNING'}

`;
  }

  // Completed tasks
  content += `## Progress

### Completed Tasks
`;
  if (opts.completedTasks && opts.completedTasks.length > 0) {
    content += opts.completedTasks.map(t => `- [x] ${t}`).join('\n') + '\n';
  } else {
    content += '- See previous session for details\n';
  }

  // Pending tasks
  content += `
### Pending Tasks
`;
  if (opts.pendingTasks && opts.pendingTasks.length > 0) {
    content += opts.pendingTasks.map(t => `- [ ] ${t}`).join('\n') + '\n';
  } else {
    content += '- Check stage outputs for pending work\n';
  }

  // Key decisions
  content += `
## Key Decisions
`;
  if (opts.keyDecisions && opts.keyDecisions.length > 0) {
    content += opts.keyDecisions.map(d => `- ${d}`).join('\n') + '\n';
  } else {
    content += '- Review stage outputs for decision history\n';
  }

  // Modified files
  content += `
## Modified Files
`;
  if (opts.modifiedFiles && opts.modifiedFiles.length > 0) {
    content += opts.modifiedFiles.map(f => `- \`${f}\``).join('\n') + '\n';
  } else {
    content += '- Check git status for recent changes\n';
  }

  // Active issues
  if (opts.activeIssues && opts.activeIssues.length > 0) {
    content += `
## Active Issues
`;
    content += opts.activeIssues.map(i => `- ⚠️ ${i}`).join('\n') + '\n';
  }

  // Notes
  if (opts.notes) {
    content += `
## Notes
${opts.notes}
`;
  }

  // Recovery instructions
  content += `
## Recovery Instructions

### For New Session:
1. **Read this HANDOFF.md first**
2. Check \`state/progress.json\` for current state
3. Review \`state/context/\` for recent snapshots
4. Resume from stage: **${opts.currentStage}**

### Key Files:
| File | Location |
|------|----------|
| Progress | \`state/progress.json\` |
| Snapshots | \`state/context/\` |
| Stage outputs | \`stages/${opts.currentStage}/outputs/\` |
| Checkpoints | \`state/checkpoints/\` |

### Commands to Run:
\`\`\`bash
# Check status
/status

# Continue from current stage
/run-stage ${opts.currentStage}

# Or check context
/context
\`\`\`

---
*Auto-generated by claude-symphony context manager*
`;

  return content;
}

/**
 * Get human-readable trigger reason
 */
function getTriggerReason(trigger: HandoffTrigger, contextPercent?: number): string {
  switch (trigger) {
    case 'context_low':
      return contextPercent !== undefined
        ? `Context low (${contextPercent}% remaining)`
        : 'Context low';
    case 'task_count':
      return 'Task count threshold reached';
    case 'stage_complete':
      return 'Stage completed';
    case 'critical':
      return contextPercent !== undefined
        ? `CRITICAL - Context at ${contextPercent}%`
        : 'CRITICAL - Immediate handoff required';
    case 'manual':
    default:
      return 'Manual trigger';
  }
}

/**
 * Check if handoff is needed based on context
 */
export function shouldGenerateHandoff(
  contextPercent: number,
  thresholds: { warning: number; action: number; critical: number }
): { needed: boolean; trigger: HandoffTrigger } {
  if (contextPercent <= thresholds.critical) {
    return { needed: true, trigger: 'critical' };
  }
  if (contextPercent <= thresholds.action) {
    return { needed: true, trigger: 'context_low' };
  }
  return { needed: false, trigger: 'manual' };
}

/**
 * Generate recovery HANDOFF (for /clear scenarios)
 */
export async function generateRecoveryHandoff(
  projectRoot: string,
  contextPercent: number
): Promise<HandoffResult | null> {
  return generateAutoHandoff(projectRoot, {
    trigger: contextPercent <= 40 ? 'critical' : 'context_low',
    contextPercent,
    compact: false,
  });
}
