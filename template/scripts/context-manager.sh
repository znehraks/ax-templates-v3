#!/bin/bash
# context-manager.sh - Context auto-management with Memory Relay integration
# Part of claude-symphony workflow pipeline
#
# Called by: statusline.sh, stop.sh
#
# Functions:
# - Auto-snapshot generation when context is low
# - HANDOFF.md auto-generation
# - Memory Relay signal sending (FIFO)
#
# Usage:
#   ./scripts/context-manager.sh --auto-compact [warning|critical]
#   ./scripts/context-manager.sh --status
#   ./scripts/context-manager.sh --list
#   ./scripts/context-manager.sh --generate-handoff

set -e

# Determine PROJECT_ROOT
if [ -n "$PROJECT_ROOT" ]; then
    PROJECT_ROOT="$PROJECT_ROOT"
elif [ -f "$(pwd)/state/progress.json" ]; then
    PROJECT_ROOT="$(pwd)"
else
    # Try to find it relative to this script
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
fi

# Directories and files
CONTEXT_DIR="$PROJECT_ROOT/state/context"
PROGRESS_FILE="$PROJECT_ROOT/state/progress.json"
HANDOFFS_DIR="$PROJECT_ROOT/state/handoffs"

# Memory Relay paths (check multiple locations)
MEMORY_RELAY_FIFO_GLOBAL="$HOME/.claude/memory-relay/orchestrator/signals/relay.fifo"
MEMORY_RELAY_FIFO_LOCAL="$PROJECT_ROOT/scripts/memory-relay/orchestrator/signals/relay.fifo"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure directories exist
mkdir -p "$CONTEXT_DIR"
mkdir -p "$HANDOFFS_DIR"

# Get current stage from progress.json
get_current_stage() {
    if [ -f "$PROGRESS_FILE" ] && command -v jq &> /dev/null; then
        jq -r '.current_stage // "unknown"' "$PROGRESS_FILE" 2>/dev/null || echo "unknown"
    else
        echo "unknown"
    fi
}

# Get current sprint info
get_sprint_info() {
    if [ -f "$PROGRESS_FILE" ] && command -v jq &> /dev/null; then
        local sprint=$(jq -r '.current_iteration.current_sprint // 1' "$PROGRESS_FILE" 2>/dev/null || echo "1")
        local total=$(jq -r '.current_iteration.total_sprints // 3' "$PROGRESS_FILE" 2>/dev/null || echo "3")
        echo "${sprint}/${total}"
    else
        echo "1/3"
    fi
}

# Find active Memory Relay FIFO
get_relay_fifo() {
    if [ -p "$MEMORY_RELAY_FIFO_LOCAL" ]; then
        echo "$MEMORY_RELAY_FIFO_LOCAL"
    elif [ -p "$MEMORY_RELAY_FIFO_GLOBAL" ]; then
        echo "$MEMORY_RELAY_FIFO_GLOBAL"
    else
        echo ""
    fi
}

# Generate auto-snapshot
generate_snapshot() {
    local level="${1:-warning}"
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local stage=$(get_current_stage)
    local sprint_info=$(get_sprint_info)

    local snapshot_file="$CONTEXT_DIR/auto-snapshot-${timestamp}.md"

    cat > "$snapshot_file" << EOF
# Auto-Snapshot - ${timestamp}

## Trigger
- Level: ${level}
- Stage: ${stage}
- Sprint: ${sprint_info}
- Generated: $(date -Iseconds)

## Context State
- Save trigger: context_${level}
- Remaining: (captured by statusline)

## Recovery Instructions
1. Read this snapshot
2. Check HANDOFF.md for detailed state
3. Resume work from current stage

## Notes
This snapshot was automatically generated when context dropped below threshold.
If Memory Relay is active, a new session will be started automatically.
EOF

    echo "$snapshot_file"
}

# Generate HANDOFF.md for relay
generate_handoff() {
    local level="${1:-warning}"
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local stage=$(get_current_stage)
    local sprint_info=$(get_sprint_info)

    local handoff_file="$PROJECT_ROOT/HANDOFF.md"

    # Read existing progress for more context
    local completed_stages=""
    if [ -f "$PROGRESS_FILE" ] && command -v jq &> /dev/null; then
        completed_stages=$(jq -r '
            .stages | to_entries |
            map(select(.value.status == "completed")) |
            map(.key) | join(", ")
        ' "$PROGRESS_FILE" 2>/dev/null || echo "")
    fi

    cat > "$handoff_file" << EOF
# HANDOFF - Auto-Generated
> Generated: $(date -Iseconds)
> Trigger: Context ${level}
> Stage: ${stage}

## Session Summary
- **Current Stage**: ${stage}
- **Sprint**: ${sprint_info}
- **Completed Stages**: ${completed_stages:-"none"}

## Context State
This handoff was automatically generated when context dropped below the ${level} threshold.

### Why This Handoff?
- Context window usage exceeded ${level} threshold
- Automatic handoff ensures continuity
- Previous work state preserved below

## Recovery Instructions

### For New Session:
1. Read this HANDOFF.md first
2. Check \`state/progress.json\` for current state
3. Review \`state/context/\` for recent snapshots
4. Resume from stage: **${stage}**

### Key Files:
- Progress: \`state/progress.json\`
- Snapshots: \`state/context/\`
- Stage outputs: \`stages/${stage}/outputs/\`

## Pending Tasks
Check the current stage's status for pending tasks.

## Important Notes
- This is an auto-generated handoff
- Review previous snapshots for detailed context
- Continue from where the previous session left off

---
*Auto-generated by context-manager.sh*
EOF

    # Archive copy
    cp "$handoff_file" "$HANDOFFS_DIR/handoff-${timestamp}-${stage}.md"

    echo "$handoff_file"
}

# Signal Memory Relay
signal_relay() {
    local handoff_path="$1"
    local fifo=$(get_relay_fifo)

    if [ -z "$fifo" ]; then
        return 1
    fi

    if [ -z "$TMUX" ]; then
        # Not in tmux, can't relay
        return 1
    fi

    local pane_id="${TMUX_PANE:-unknown}"
    local signal="RELAY_READY:${handoff_path}:${pane_id}"

    echo "$signal" > "$fifo"
    return 0
}

# Show status
show_status() {
    echo ""
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}  Context Manager Status${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"

    local stage=$(get_current_stage)
    local sprint_info=$(get_sprint_info)
    local fifo=$(get_relay_fifo)

    echo ""
    echo -e "  ${BLUE}Current Stage:${NC} $stage"
    echo -e "  ${BLUE}Sprint:${NC} $sprint_info"

    # Memory Relay status
    echo ""
    if [ -n "$fifo" ]; then
        echo -e "  ${GREEN}Memory Relay:${NC} Active"
        echo -e "    FIFO: $fifo"
    else
        echo -e "  ${YELLOW}Memory Relay:${NC} Not running"
        echo -e "    Run 'claude-symphony-play' for auto-relay"
    fi

    # Snapshots
    echo ""
    local snapshot_count=$(ls -1 "$CONTEXT_DIR"/auto-snapshot-*.md 2>/dev/null | wc -l | tr -d ' ')
    echo -e "  ${BLUE}Snapshots:${NC} $snapshot_count saved"

    # Latest snapshot
    local latest=$(ls -1t "$CONTEXT_DIR"/auto-snapshot-*.md 2>/dev/null | head -1)
    if [ -n "$latest" ]; then
        echo -e "    Latest: $(basename "$latest")"
    fi

    # tmux status
    echo ""
    if [ -n "$TMUX" ]; then
        echo -e "  ${GREEN}tmux:${NC} Active"
    else
        echo -e "  ${YELLOW}tmux:${NC} Not in tmux session"
    fi

    echo ""
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# List snapshots
list_snapshots() {
    echo ""
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${CYAN}  Context Snapshots${NC}"
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo ""

    local snapshots=$(ls -1t "$CONTEXT_DIR"/auto-snapshot-*.md 2>/dev/null)

    if [ -z "$snapshots" ]; then
        echo -e "  ${YELLOW}No snapshots found${NC}"
    else
        local count=0
        while IFS= read -r snapshot; do
            count=$((count + 1))
            local basename=$(basename "$snapshot")
            local timestamp=$(echo "$basename" | sed 's/auto-snapshot-\(.*\)\.md/\1/')

            if [ $count -le 10 ]; then
                echo -e "  ${count}. ${basename}"
            fi
        done <<< "$snapshots"

        local total=$(echo "$snapshots" | wc -l | tr -d ' ')
        if [ "$total" -gt 10 ]; then
            echo ""
            echo -e "  ... and $((total - 10)) more"
        fi
    fi

    echo ""
    echo -e "${CYAN}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
}

# Auto-compact handler (main function called by hooks)
auto_compact() {
    local level="${1:-warning}"

    # 1. Generate snapshot
    local snapshot_file=$(generate_snapshot "$level")

    # 2. Generate HANDOFF.md
    local handoff_file=$(generate_handoff "$level")

    # 3. Signal Memory Relay if available
    local fifo=$(get_relay_fifo)
    if [ -n "$fifo" ] && [ -n "$TMUX" ]; then
        if signal_relay "$handoff_file"; then
            echo -e "${GREEN}[Context Manager]${NC} Relay signal sent"
            echo "  Snapshot: $(basename "$snapshot_file")"
            echo "  Handoff: $handoff_file"
            return 0
        fi
    fi

    # No relay available - return snapshot path
    echo "$snapshot_file"
}

# Main command dispatcher
case "${1:-}" in
    --auto-compact)
        auto_compact "${2:-warning}"
        ;;
    --status)
        show_status
        ;;
    --list)
        list_snapshots
        ;;
    --generate-handoff)
        generate_handoff "${2:-manual}"
        ;;
    --help|-h|"")
        echo "Usage: context-manager.sh [command]"
        echo ""
        echo "Commands:"
        echo "  --auto-compact [level]  Generate snapshot and HANDOFF, signal relay"
        echo "  --status                Show context manager status"
        echo "  --list                  List saved snapshots"
        echo "  --generate-handoff      Generate HANDOFF.md manually"
        echo "  --help                  Show this help"
        echo ""
        echo "Levels: warning, critical"
        ;;
    *)
        echo "Unknown command: $1"
        echo "Run with --help for usage"
        exit 1
        ;;
esac
